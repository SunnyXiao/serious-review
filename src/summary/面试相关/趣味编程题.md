<!--
 * @Author:luisa xiao
 * @Date: 2020-02-14 17:03:06
 * @LastEditTime: 2020-02-28 10:14:46
 * @LastEditors: Please set LastEditors
 * @Description: 小编程，大知识
 * @FilePath: /rm-portal/work/xly/project/serious-review/src/summary/面试相关/趣味编程题.md
 -->

<!--待续。。。。。-->
### code 1
```
    var foo = function bar () {
      return 12
    }
    console.log(typeof bar())
```

答案：输出是抛出异常，bar is not defined。

解析：这种命名函数表达式函数只能在函数体内有效


### code 2
```
    function f () {
      return f;
    }

    console.log(new f() instanceof f)
```

答案： false
解析：
a instanceof b 用于检测a是不是b的实例。如果题目f中没有return f,则答案明显为true;而在本题中new f()其返回的结果为f的函数对象，其并不是f的一个实例。

### code 3
```
  var a = {n:1}
  var b = a;
  a.x = a = {n:2}

  console.log(b,a)

```
答案： {n:1,x:{n:2}}, {n:2}
解析：执行时根据运算符的优先级，先执行a.x，此时a.x引用的是{n:1},然后表达式再从右往左执行

### code 4

```
  var name = "Tom";
  (function(){
    if(typeof name == 'undefined'){
      var name = 'jack'
      console.log('Good' + name)
    } else {
      console.log('Hello' + name)
    }
  })();
```
答案： Good jack 
解析：


### code 5

```
  const person = {name: "Jon"};

  function sayHi(age) {
    return `${this.name} is ${age}`
  }

  console.log(sayHi.call(person, 5))
  console.log(sayHi.bind(person, 5))
```

答案： Jon is 5，  function
解析：
俩者都可以传递我们想要this关键字引用的对象。但是call和apply方法会立即执行！bind方法会返回函数的拷贝值，但带有绑定的上下文！他不会立即执行。

### code 6

```
  const num = {
    a: 10,
    add(){
      return this.a + 2;
    },
    reduce: () => {
      this.a -2;
    }
  }
  console.log(num.add())
  console.log(num.reduce())
```
答案： 12 NaN
解析：add是普通函数，reduce是箭头函数，对于箭头函数，·this· 关键字指向的是它所在上下文的环境

### code 7
```
  var x = 1
  if(function f(){}) {
      x+= typeof f;
  }
  console.log(x)
```